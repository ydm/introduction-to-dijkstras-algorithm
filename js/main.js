// Generated by CoffeeScript 1.6.3
(function() {
  var dijkstra, dist_between, get_edges, get_hash, get_neighbours, get_vertexes, navigate, populateSelect, smallest_dist, solve, trace;

  get_hash = function() {
    var hash;
    hash = location.hash.slice(1);
    return hash || 'home';
  };

  navigate = function() {
    var all, c, hash, hide, show, target, _i, _len;
    hash = get_hash();
    all = ['_home', '_graph', '_algorithm'];
    target = "_" + hash;
    hide = function(c) {
      $("." + c).hide();
      return $("." + c + "_nav").removeClass('active');
    };
    show = function(c) {
      $("." + c).show();
      return $("." + c + "_nav").addClass('active');
    };
    for (_i = 0, _len = all.length; _i < _len; _i++) {
      c = all[_i];
      if (c !== target) {
        hide(c);
      }
    }
    show(target);
    return $(window).trigger("pageshow-" + hash);
  };

  $(window).on('hashchange', navigate);

  $(navigate);

  $('._edgeDeleteButton').click(function() {
    return $(this).parents('._edgeRow').remove();
  });

  $('#addEdgeButton').click(function() {
    var clone, model;
    model = $('#edgeRowModel');
    clone = model.clone(true, true);
    clone.removeClass('hide');
    clone.attr('id', '');
    return $('#edgeTableBody').append(clone);
  });

  get_edges = function() {
    "Return a list of all edges as defined in this page.";
    var arr;
    arr = $.map($('._edgeRow'), function(element, index) {
      var end, start, weight;
      start = $(element).find('._startVertex').val();
      end = $(element).find('._endVertex').val();
      weight = parseInt($(element).find('._edgeWeight').val(), 10);
      if (start && end && weight) {
        return {
          start: start,
          end: end,
          weight: weight
        };
      } else {
        return null;
      }
    });
    return arr.filter(function(e) {
      return e;
    });
  };

  get_vertexes = function() {
    var arr, set, x, _results;
    set = {};
    arr = $.map($('._edgeRow'), function(element, index) {
      var end, start;
      start = $(element).find('._startVertex').val();
      end = $(element).find('._endVertex').val();
      if (start && !set.hasOwnProperty(start)) {
        set[start] = true;
      }
      if (end && !set.hasOwnProperty(end)) {
        return set[end] = true;
      }
    });
    _results = [];
    for (x in set) {
      if (set.hasOwnProperty(x)) {
        _results.push(x);
      }
    }
    return _results;
  };

  smallest_dist = function(vertexes, dist) {
    var min, minVertex, vertex, _i, _len;
    min = Infinity;
    minVertex = null;
    for (_i = 0, _len = vertexes.length; _i < _len; _i++) {
      vertex = vertexes[_i];
      if (dist.hasOwnProperty(vertex) && dist[vertex] < min) {
        min = dist[vertex];
        minVertex = vertex;
      }
    }
    return minVertex;
  };

  get_neighbours = function(vertex, edges) {
    var edge, ret, _i, _len;
    ret = [];
    for (_i = 0, _len = edges.length; _i < _len; _i++) {
      edge = edges[_i];
      if (edge.start === vertex) {
        ret.push(edge.end);
      } else if (edge.end === vertex) {
        ret.push(edge.start);
      }
    }
    return ret;
  };

  dist_between = function(v, u, edges) {
    var edge, _i, _len;
    for (_i = 0, _len = edges.length; _i < _len; _i++) {
      edge = edges[_i];
      if ((edge.start === v && edge.end === u) || (edge.start === u && edge.end === v)) {
        return edge.weight;
      }
    }
    throw new Error("No edge between " + u + " and " + v);
  };

  trace = function(start, paths) {
    var S;
    S = [];
    while (paths[start]) {
      S.push(start);
      start = paths[start];
    }
    return S.reverse();
  };

  dijkstra = function(vertexes, edges, source, target) {
    var Q, S, alt, dist, previous, u, v, vertex, _i, _j, _len, _len1, _ref;
    dist = {};
    previous = {};
    for (_i = 0, _len = vertexes.length; _i < _len; _i++) {
      vertex = vertexes[_i];
      dist[vertex] = Infinity;
      previous[vertex] = null;
    }
    dist[source] = 0;
    Q = (function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = vertexes.length; _j < _len1; _j++) {
        v = vertexes[_j];
        _results.push(v);
      }
      return _results;
    })();
    while (Q.length > 0) {
      u = smallest_dist(Q, dist);
      if (u === target) {
        S = trace(target, previous);
        S.unshift(source);
        return S;
      }
      Q.splice(Q.indexOf(u), 1);
      if (dist[u] === Infinity) {
        break;
      }
      _ref = get_neighbours(u, edges);
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        v = _ref[_j];
        alt = dist[u] + dist_between(u, v, edges);
        if (alt < dist[v]) {
          dist[v] = alt;
          previous[v] = u;
        }
      }
    }
    return [];
  };

  populateSelect = function(id, values) {
    var val, _i, _len, _results;
    $("#" + id).empty();
    _results = [];
    for (_i = 0, _len = values.length; _i < _len; _i++) {
      val = values[_i];
      _results.push($("#" + id).append($("<option value=\"" + val + "\">" + val + "</option>")));
    }
    return _results;
  };

  $(window).bind('pageshow-algorithm', function() {
    var vertexes;
    vertexes = get_vertexes();
    populateSelect('startVertexSelect', vertexes);
    return populateSelect('endVertexSelect', vertexes);
  });

  solve = function() {
    var edges, end, path, start;
    start = $('#startVertexSelect').val();
    end = $('#endVertexSelect').val();
    edges = get_edges();
    path = dijkstra(get_vertexes(), edges, start, end);
    $('#solutionTable').empty();
    return path.reduce(function(prev, current, index, array) {
      var dist;
      dist = dist_between(prev, current, edges);
      $('#solutionTable').append("<tr>  <td>" + index + "</td>  <td>" + prev + "</td>  <td>" + current + "</td>  <td>" + dist + "</td></tr>");
      return current;
    });
  };

  $(function() {
    $('#startVertexSelect').change(solve);
    return $('#endVertexSelect').change(solve);
  });

}).call(this);
